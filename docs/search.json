[
  {
    "objectID": "ssh.html",
    "href": "ssh.html",
    "title": "Remote logins and SSH",
    "section": "",
    "text": "What happens when we want to run some commands on another machine, such as Pawsey’s Setonix? To do this, we have to first log in to that machine. We call this a remote login.\nIn order for us to be able to login, the remote computer must be running a remote login server and we will run a client program that can talk to that server. The client program passes our login credentials to the remote login server and, if we are allowed to login, that server then runs a shell for us on the remote computer.\nOnce our local client is connected to the remote server, everything we type into the client is passed on, by the server, to the shell running on the remote computer. That remote shell runs those commands on our behalf, just as a local shell would, then sends back output, via the server, to our client, for our computer to display.",
    "crumbs": [
      "Additional resources",
      "Remote logins and SSH"
    ]
  },
  {
    "objectID": "ssh.html#background",
    "href": "ssh.html#background",
    "title": "Remote logins and SSH",
    "section": "1 Background",
    "text": "1 Background\nBack in the day, when everyone trusted each other and knew every chip in their computer by its first name, people didn’t encrypt anything except the most sensitive information when sending it over a network and the two programs used for running a shell (usually back then, the Bourne Shell, sh) on, or copying files to, a remote machine were named rsh and rcp, respectively. Think (r)emote sh and cp.\nHowever, anyone could watch the unencrypted network traffic, which meant that villains could steal usernames and passwords. The SSH protocol was invented to prevent this (or at least slow it down). It uses several sophisticated, and heavily tested, encryption protocols to ensure that outsiders can’t see what’s in the messages going back and forth between different computers.\nThe remote login server which accepts connections from client programs is known as the SSH daemon. The client program we use to login remotely is the secure shell or SSH (think (s)ecure sh).",
    "crumbs": [
      "Additional resources",
      "Remote logins and SSH"
    ]
  },
  {
    "objectID": "ssh.html#logging-in-using-ssh",
    "href": "ssh.html#logging-in-using-ssh",
    "title": "Remote logins and SSH",
    "section": "2 Logging in using ssh",
    "text": "2 Logging in using ssh\nTo make a remote login, we issue the command ssh &lt;username&gt;@&lt;computer&gt; which tries to make a connection to the SSH daemon running on the remote computer we have specified. For Chitra to access the Setonix computer on Pawsey, she logs in using ssh chitrams@setonix.pawsey.org.au.\n\n\n\n\n\n\nTest your understanding\n\n\n\n\nWhat happens if Chitra has already been allocated a node named nid09310 that she would like to directly log in to?\nWhat happens if Chitra wants to access the data mover nodes on Pawsey, which has the hostname data-mover.pawsey.org.au?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFor the first instance, Chitra would log in with the following command:\nssh chitrams@nid09310.pawsey.org.au\nFor the second, Chitra would log in with the following command:\nsftp chitrams@data-mover.pawseyl.org.au\nwhere sftp is another companion program for ssh, the Secure File Transfer Protocol. We talk about this in Section 4.\n\n\n\nAfter we log in, we can use the remote shell to use the remote computer’s files and directories.\nTyping exit terminates the remote shell (and the local client program on that remote shell) and returns us to our previous shell.",
    "crumbs": [
      "Additional resources",
      "Remote logins and SSH"
    ]
  },
  {
    "objectID": "ssh.html#sec-sshkeys",
    "href": "ssh.html#sec-sshkeys",
    "title": "Remote logins and SSH",
    "section": "3 SSH keys",
    "text": "3 SSH keys\nSSH keys provide a more secure and streamlined way of authenticating to remote systems compared to traditional password-based login methods. Instead of relying on a potentially weak password that can be guessed or intercepted, SSH keys use a robust cryptographic authentication mechanism. By implementing SSH keys, you’re not just avoiding the inconvenience of repeated password entry; you’re fundamentally improving your system’s security and authentication reliability.\nSSH keys come in pairs: a public key that gets shared with services like GitHub, and a private key that is stored only on your computer. If the keys match, you’re granted access. The cryptography behind SSH keys ensures that no one can reverse engineer your private key from the public one.\nWhen you generate an SSH key, you can add a passphrase to further secure the key. Whenever you use the key, you must enter the passphrase. If your key has a passphrase and you don’t want to enter the passphrase every time you use the key, you can add your key to the SSH agent. The SSH agent manages your SSH keys and remembers your passphrase.\nThe first step in using SSH authorization is to generate your own key pair. You might already have an SSH key pair on your machine. You can check to see if one exists by moving to your .ssh directory and listing the contents.\n$ cd ~/.ssh\n$ ls\nIf you see id_rsa.pub, you already have a key pair and don’t need to create a new one. If you don’t see any, follow the instructions below to generate a key pair.\n\n3.1 Generating a key pair for GitHub\nYou can generate a new SSH key on your local machine. After you generate the key, you can add the public key to your account on GitHub.com to enable authentication for Git operations over SSH.\n\n3.1.1 Generate a new SSH key pair\n\nOpen a Terminal and paste the text below, replacing the email used in the example with your GitHub email address.\nssh-keygen -t ed25519 -C \"your_email@example.com\" -f ~/.ssh/github_ed25519_key\nThis creates a new SSH key, using the provided email as a label, and github_ed25519_key as the key name.\n&gt; Generating public/private ALGORITHM key pair.\nAt the prompt, type a secure passphrase.\n&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]\n&gt; Enter same passphrase again: [Type passphrase again]\n\n\n\n3.1.2 Add the keys to your machine’s SSH agent\n\nStart the ssh-agent in the background.\n$ eval \"$(ssh-agent -s)\" \n&gt; Agent pid 59566\nDepending on your environment, you may need to use a different command. For example, you may need to use root access by running sudo -s -H before starting the ssh-agent, or you may need to use exec ssh-agent bash or exec ssh-agent zsh to run the ssh-agent.\nIf you’re using macOS Sierra 10.12.2 or later, you will need to modify your ~/.ssh/config file to automatically load keys into the ssh-agent and store passphrases in your keychain.\n\nFirst, check to see if your ~/.ssh/config file exists in the default location.\n\n$ open ~/.ssh/config\n&gt; The file /Users/YOU/.ssh/config does not exist.\n\nIf the file doesn’t exist, create the file.\n\ntouch ~/.ssh/config\n\nOpen your ~/.ssh/config file, then modify the file to contain the following lines. If your SSH key file has a different name or path than the example code, modify the filename or path to match your current setup.\n\nHost setonix\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/github_ed25519_key\n\n\n\n\n\n\nNote\n\n\n\nIf you chose not to add a passphrase to your key, you should omit the UseKeychain line.\nIf you see a Bad configuration option: usekeychain error, add an additional line to the configuration’s Host *.github.com section.\nHost github.com\n  IgnoreUnknown UseKeychain\n\n\nAdd your SSH private key to the ssh-agent and store your passphrase in the keychain. If you created your key with a different name, or if you are adding an existing key that has a different name, replace github_ed25519_key in the command with the name of your private key file.\nssh-add --apple-use-keychain ~/.ssh/github_ed25519_key\n\n\n\n\n\n\nNote\n\n\n\nThe --apple-use-keychain option stores the passphrase in your keychain for you when you add an SSH key to the ssh-agent. If you chose not to add a passphrase to your key, run the command without the --apple-use-keychain option.\nThe --apple-use-keychain option is in Apple’s standard version of ssh-add. In macOS versions prior to Monterey (12.0), the --apple-use-keychain and --apple-load-keychain flags used the syntax -K and -A, respectively.\nIf you continue to be prompted for your passphrase, you may need to add the command to your ~/.zshrc file (or your ~/.bashrc file for bash).\n\n\n\n\n\n3.1.3 Add the public key to your account on GitHub\n\nCopy the SSH public key to your clipboard. If your SSH public key file has a different name than the example code, modify the filename to match your current setup. When copying your key, don’t add any newlines or whitespace.\n$ pbcopy &lt; ~/.ssh/github_ed25519_key.pub\n# Copies the contents of the github_ed25519_key.pub file to your clipboard\n\n\n\n\n\n\nIf pbcopy doesn’t work\n\n\n\n\n\nIf pbcopy isn’t working, you can locate the hidden .ssh folder, open the file in your favorite text editor, and copy it to your clipboard.\n\n\n\nIn the upper-right corner of any page on GitHub, click your profile photo, then click Settings.\nIn the “Access” section of the sidebar, click SSH and GPG keys.\nClick New SSH key or Add SSH key.\nIn the “Title” field, add a descriptive label for the new key. For example, if you’re using a personal laptop, you might call this key “Personal laptop”.\nSelect the type of key: in this instance, we want to set up a key for authentication.\nIn the “Key” field, paste your public key.\nClick Add SSH key.\nIf prompted, confirm access to your account on GitHub.\n\nLink to GitHub documentation here.\n\n\n\n3.2 Generating a key pair for Pawsey\n\n3.2.1 Generate a new SSH key pair\n\nOpen a terminal and execute the following command:\nssh-keygen -t ed25519 -f ~/.ssh/pawsey_ed25519_key\nAt the prompt, type a secure passphrase.\n&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]\n&gt; Enter same passphrase again: [Type passphrase again]\n\n\n\n3.2.2 Add the keys to your machine’s SSH agent\n\nStart the ssh-agent in the background.\n$ eval \"$(ssh-agent -s)\"\n&gt; Agent pid 59566\nDepending on your environment, you may need to use a different command. For example, you may need to use root access by running sudo -s -H before starting the ssh-agent, or you may need to use exec ssh-agent bash or exec ssh-agent zsh to run the ssh-agent.\nIf you’re using macOS Sierra 10.12.2 or later, you will need to modify your ~/.ssh/config file to automatically load keys into the ssh-agent and store passphrases in your keychain.\n\nFirst, check to see if your ~/.ssh/config file exists in the default location using the following command:\n\n$ open ~/.ssh/config\n&gt; The file /Users/YOU/.ssh/config does not exist.\n\nIf the file doesn’t exist, create the file.\n\ntouch ~/.ssh/config\n\nOpen your ~/.ssh/config file, then modify the file to contain the following lines. If your SSH key file has a different name or path than the example code, modify the filename or path to match your current setup.\n\nHost setonix\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/pawsey_ed25519_key\n\n\n\n\n\n\nNote\n\n\n\nIf you chose not to add a passphrase to your key, you should omit the UseKeychain line.\nIf you see a Bad configuration option: usekeychain error, add an additional line to the configuration’s Host setonix section.\nHost setonix\n  IgnoreUnknown UseKeychain\n\n\n\n\n\n3.2.3 Add the public key to Setonix\nOn your local machine, execute the following command:\nssh-copy-id -i ~/.ssh/pawsey_ed25519_key.pub &lt;username&gt;@&lt;remotehost&gt;\nWhere &lt;username&gt; is your Pawsey username and &lt;remotehost&gt; is the remote host to be accessed (usually setonix.pawsey.org.au). If the command establishes the correct connection to the host, then it will ask for your password to accept and finalise the copy.",
    "crumbs": [
      "Additional resources",
      "Remote logins and SSH"
    ]
  },
  {
    "objectID": "ssh.html#sec-file-transfer",
    "href": "ssh.html#sec-file-transfer",
    "title": "Remote logins and SSH",
    "section": "4 Secure file transfers",
    "text": "4 Secure file transfers\nThe ssh login client has companion programs called scp (think (s)ecure cp) and sftp (short for Secure File Transfer Protocol) which allows us to copy files to or from a remote computer using the same kind of encrypted connection as SSH.\nCommand line clients such as scp and sftp are a convenient way of moving data between computers. Alternatively, you could use GUI clients such as Filezilla, Cyberduck, or WinSCP.\n\n\n\n\n\n\nUse SSH keys!\n\n\n\nWhichever you use, it is strongly recommended to use SSH keys instead of the conventional and less secure username and password. See Section 3 for information on SSH keys.\n\n\n\n4.1 scp\nscp is useful to copy few small files and not a lot or very large files. It is not recommended for the transfer of large amounts of data, as it can’t resume transfers if the operation/connection is interrupted for any reason.\nThe syntax for scp is:\nscp &lt;options&gt; &lt;path/to/source&gt; &lt;user-name&gt;@data-mover.pawsey.org.au:&lt;path/to/destination&gt;\n\nscp &lt;options&gt; &lt;user-name&gt;@data-mover.pawsey.org.au:&lt;path/to/source&gt; &lt;path/to/destination&gt; \nNote the use of the colon (:) separating the hostname and the definition of the path/files on it.\nLet’s look at an example. For Chitra to transfer the file “/VIMC/launch.R” from a local computer into her personal directory in “/scratch”, she would use:\n$ scp /VIMC/launch.R chitrams@data-mover.pawsey.org.au:/scratch/pawsey1104/chitrams\nOn Pawsey, your personal directory in scratch will always look like: /scratch/&lt;project-name&gt;/&lt;user-name&gt;.\nTo transfer a whole directory tree recursively, then the option -r needs to be used. As an example:\nscp -r chitra-ms@data-mover.pawsey.org.au:/scratch/pawsey1104/chitrams/vimc-pawsey/output ./pawsey-files\n\n\n4.2 sftp\n\n\n4.3 GUI clients\nGUI clients are a very attractive option for file transfers because of their intuitive framework. They have the advantage that users do not need to remember the several different options for the command-line tools, but keep in mind these GUI clients are still based on the command line clients listed above. In practice, the combined use of both GUI and command line clients within your workflows results in better efficiency.\nPawsey recommends the file transfer clients FileZilla (available for Windows, MacOS, and Linux), Cyberduck (available for MacOS and Windows), or WinSCP (available for Windows).\n\n\n\n\n\n\nDownloading software\n\n\n\nOnly download these tools from its official website:\n\nFilezilla: filezilla-project.org/index.php\nCyberduck: cyberduck.io\nWinSCP: winscp.net/eng/index.php\n\nAs for any software, be careful of not falling into “click tricks” that mislead you to download or install undesired software.\n\n\n\n\n\n\n\n\nAuthentication\n\n\n\nSaving your password within the GUI client is not recommended. Instead, use SSH keys. See Section 3 for information on SSH keys.\n\n\n::::::",
    "crumbs": [
      "Additional resources",
      "Remote logins and SSH"
    ]
  },
  {
    "objectID": "code-of-conduct.html",
    "href": "code-of-conduct.html",
    "title": "Code of Conduct",
    "section": "",
    "text": "The organisers of this workshop are dedicated to providing a safe, inclusive, welcoming, and harassment-free experience for everyone. \n\nExpected Behaviour \nWe aim to create an inclusive learning environment where:\n\npeople feel comfortable exploring ideas;\nasking questions is encouraged and welcomed;\nno question is considered “stupid”;\nparticipants assume competence in one another;\ncuriosity and genuine learning are celebrated.\n\nParticipants are expected to engage in respectful interaction throughout the workshop. We request that participants:\n\nare considerate in their speech and actions;\nactively acknowledge and respect others’ personal boundaries;\npractice empathy and active listening;\noffer constructive, kind feedback;\nseek to understand before being understood.\n\n\n\nParticipation Guidelines\n\nBe fully present during workshop sessions.\nAvoid working on unrelated projects during workshop time.\nRespect the workshop organizers’ and facilitators’ time and effort.\nContribute to a collaborative and supportive learning environment.\n\n\n\nUnacceptable Behavior\nThe following behaviors are not tolerated:\n\ncombative or argumentative conduct;\nveiled criticisms disguised as questions (e.g., “Have you thought about…”);\ninterrupting or talking over others;\ndismissive or condescending remarks;\nany form of harassment, including: discriminatory language or jokes; unwelcome sexual advances; intimidation or bullying; and offensive comments related to gender, sexual orientation, race, religion, disability, or age.\n\nBy participating in this workshop, you agree to uphold these principles and contribute to a positive and supportive learning environment. \n\n\nReporting Guidelines \nThe Code of Conduct Committee includes Melissa Penny, Chitra M Saraswati, and #TODO XXX. \nIf you witness or experience inappropriate behaviour, or have any other concerns, please alert a member of the Code of Conduct Committee immediately. Even if an incident seems minor, reporting helps maintain a safe environment for everyone. \nViolation of the Code of Conduct will result in a warning, asking a participant to leave a session, or removal from the entire workshop.",
    "crumbs": [
      "Code of Conduct"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setting up",
    "section": "",
    "text": "To participate in the workshop, you will need access to software as described below. In addition, you will need an up-to-date web browser.\nThere is a list of common issues that occur during installation, as a reference for instructors, that may be useful in the following wiki page: Configuration Problems and Solutions.",
    "crumbs": [
      "Additional resources",
      "Setting up"
    ]
  },
  {
    "objectID": "setup.html#the-bash-shell",
    "href": "setup.html#the-bash-shell",
    "title": "Setting up",
    "section": "1 The Bash shell",
    "text": "1 The Bash shell\n\nMacOSWindowsLinux\n\n\nThe default shell in Mac OS X Ventura and newer versions is Zsh, but Bash is available in all versions, so no need to install anything. You access Bash from the Terminal (found in /Applications/Utilities). See the video tutorial below for an example on how to open the Terminal. You may want to keep Terminal in your dock for this workshop.\nTo see if your default shell is Bash type echo $SHELL in Terminal and press the Return key. If the message printed does not end with ‘/bash’ then your default is something else, you can change your current shell to Bash by typing bash and then pressing Return. To check your current shell type echo $0 and press Return.\nTo change your default shell to Bash type chsh -s /bin/bash and press the Return key, then reboot for the change to take effect.\nTo change your default back to Zsh, type chsh -s /bin/zsh, press the Return key and reboot.\nTo check available shells, type cat /etc/shells.\n\n\n\n\nDownload the Git for Windows installer.\nRun the installer and follow the steps below:\n\nClick on Next four times (two times if you’ve previously installed Git). You don’t need to change anything in the Information, location, components, and start menu screens.\nFrom the dropdown menu Choosing the default editor used by Git, select Use the Nano editor by default (note: you will need to scroll up to find it), then click on Next.\nOn the page that says Adjusting the name of the initial branch in new repositories, ensure that Let Git decide is selected. This will ensure the highest level of compatibility for our lessons.\nEnsure that Git from the command line and also from 3rd-party software is selected and click on Next. (If you don’t do this, Git Bash will not work properly, requiring you to remove the Git Bash installation, re-run the installer and to select the Git from the command line and also from 3rd-party software option.)\nSelect Use bundled OpenSSH.\nEnsure that Use the native Windows Secure Channel Library is selected and click on Next.\nEnsure that Checkout Windows-style, commit Unix-style line endings is selected and click on Next.\nEnsure that Use Windows’ default console window is selected and click Next.\nEnsure that Default (fast-forward or merge) is selected and click Next.\nEnsure that Git Credential Manager is selected and click on Next.\nEnsure that Enable file system caching is selected and click on Next.\nClick on Install.\nClick on Finish or Next.\n\nIf your “HOME” environment variable is not set (or you don’t know what this is):\n\nOpen command prompt (Open the Start Menu, then type cmd and press Enter)\nType the following line into the command prompt window, exactly as shown: setx HOME \"%USERPROFILE%\"\nPress Enter and you should see SUCCESS: Specified value was saved.\nQuit the command prompt by typing exit then pressing Enter.\n\n\nThis will provide you with both Git and Bash in the Git Bash program.\n\n\n\nThe default shell is usually Bash and there is usually no need to install anything.\nTo see if your default shell is Bash type echo $SHELL in Terminal and press the Return key. If the message printed does not end with ‘/bash’ then your default is something else, you can change your current shell to Bash by typing bash and then pressing Return. To check your current shell type echo $0 and press Return.\nTo change your default shell to Bash type chsh -s /bin/bash and press the Return key, then reboot for the change to take effect. To change your default back to Zsh, type chsh -s /bin/zsh, press the Return key and reboot. To check available shells, type cat /etc/shells.",
    "crumbs": [
      "Additional resources",
      "Setting up"
    ]
  },
  {
    "objectID": "setup.html#git",
    "href": "setup.html#git",
    "title": "Setting up",
    "section": "2 Git",
    "text": "2 Git\nGit is a version control system that lets you track who made changes to what when and has options for easily updating a shared or public version of your code on github.com. You will need a supported web browser.\nYou will need an account at github.com for parts of the Git lesson. When setting up your GitHub account, please consider what personal information you’d like to reveal. For example, you may want to review these instructions for keeping your email address private provided at GitHub.\n\nMacOSWindowsLinux\n\n\nPlease open the Terminal app, type git --version and press Return. If it’s not installed already, follow the instructions to install the “command line developer tools”. Do not click Get Xcode, because that will take too long and is not necessary for our Git lesson. After installing these tools, there won’t be anything in your /Applications folder, as they and Git are command line programs.\nFor older versions of OS X (10.5-10.8): use the most recent available installer labelled “snow-leopard” available here. (Note: this project is no longer maintained.) Because this installer is not signed by the developer, you may have to right click (Control + click) on the .pkg file, and then click Open in the pop-up dialog. You can watch the video tutorial below for this.\n\n\n\nGit should be installed on your computer as part of your Bash install.\n\n\nIf Git is not already available on your machine you can try to install it via your distro’s package manager. For Debian/Ubuntu run sudo apt-get install git and for Fedora run sudo dnf install git.",
    "crumbs": [
      "Additional resources",
      "Setting up"
    ]
  },
  {
    "objectID": "setup.html#text-editor",
    "href": "setup.html#text-editor",
    "title": "Setting up",
    "section": "3 Text editor",
    "text": "3 Text editor\nWhen you’re writing code, it’s nice to have a text editor that is optimized for writing code, with features like automatic color-coding of key words. The default text editor on macOS and Linux is usually set to Vim, which is not famous for being intuitive. If you accidentally find yourself stuck in it, hit the Esc key, followed by : + q + ! (colon, lower-case ‘q’, exclamation mark), then hitting Return to return to the shell.\n\nMacOSWindowsLinux\n\n\nnano is a basic editor and the default that instructors use in the workshop. See the Git installation video tutorial, also provided below, for an example on how to open nano. It should be pre-installed.\n\n\n\nnano is a basic editor and the default that instructors use in the workshop. It is installed along with Git.\n\n\nnano is a basic editor and the default that instructors use in the workshop. It should be pre-installed.\n\n\n\nYou can refer to our guide for nano or guide for vim under our Resources pages.",
    "crumbs": [
      "Additional resources",
      "Setting up"
    ]
  },
  {
    "objectID": "session-2.html#file-transfers-more-ssh",
    "href": "session-2.html#file-transfers-more-ssh",
    "title": "Session 2",
    "section": "2 File transfers (more SSH)",
    "text": "2 File transfers (more SSH)\n\n\n\n\n\n\nObjectives\n\n\n\n\nUse SCP and SFTP for file transfers\nUse the command line for basic file operations\nUse the text editor Vim\n\n\n\n\nLog in to an SFTP session. Transfer the folder secret-files within your scratch directory to your local PC.\n\n\n\n\n\n\n\nWarning\n\n\n\nIt’s tempting to use your PC’s GUI, but please use the command line for the next steps in this exercise!\n\n\n\nOpen a new terminal window for your local PC. Navigate to the secret-files directory on your local PC and open the file unmodified-secret-scenario.xml using Vim.\nThere are some values in that file that needs to be substituted; they look like: @parameter@. Find these and change them.\nWhen you’re done changing all the values, rename the file to secret-scenario.xml using the command mv.\nUsing SCP, transfer the file secret-scenario.xml to the secret-files folder within your scratch directory on Pawsey.\n\n\n\n\n\n\n\nDiscussion\n\n\n\nWhen do you think you would use SCP, SFTP, and Rsync? Which method do you think is quicker? And when would you use GUIs?"
  },
  {
    "objectID": "session-2.html#software-on-hpc",
    "href": "session-2.html#software-on-hpc",
    "title": "Session 2",
    "section": "3 Software on HPC",
    "text": "3 Software on HPC"
  },
  {
    "objectID": "session-2.html#job-scheduling-slurm",
    "href": "session-2.html#job-scheduling-slurm",
    "title": "Session 2",
    "section": "4 Job scheduling (Slurm)",
    "text": "4 Job scheduling (Slurm)"
  },
  {
    "objectID": "nano.html",
    "href": "nano.html",
    "title": "Text editors: nano",
    "section": "",
    "text": "nano is an easy-to-use command line text editor for Unix and Linux operating systems. It includes all the basic functionality you’d expect from a regular text editor, like syntax highlighting, multiple buffers, search and replace with regular expression support, spellchecking, UTF-8 encoding, and more.\nWe will go through the basics of using nano, including: how to create and open a file, edit a file, save a file, search and replace text, and cut and paste text.",
    "crumbs": [
      "Additional resources",
      "Text editors: nano"
    ]
  },
  {
    "objectID": "nano.html#starting-nano",
    "href": "nano.html#starting-nano",
    "title": "Text editors: nano",
    "section": "1 Starting nano",
    "text": "1 Starting nano\nNano text editor is pre-installed on macOS and most Linux distributions. To check if it is installed on your system, type:\nnano --version\nTo open an existing file or to create a new file, type nano followed by the file name:\nnano filename\nThis opens a new editor window, and you can start editing the file. nano is a “modeless” editor. All keys, with the exception of Control and Meta (Alt or Option) key sequences, will enter text into the file being edited.\nAt the bottom of the window, there is a list of the most basic command shortcuts to use with the nano editor. All commands are prefixed with either ^ or M characters. The caret symbol (^) represents the Ctrl key. For example, the ^J command means to press the Ctrl and J keys at the same time. The letter M represents the Alt or Option key. You can get a list of all commands by typing Ctrl + g.\nTo move the cursor to a specific line and character number, use the command Ctrl + _. The menu at the bottom of the screen will change. Enter the number(s) in the “Enter line number, column number:” field and hit Enter.\nTo open a file, you must have read permissions to the file. If you want to open a file with the cursor on a specific line and character, use the following syntax:\nnano +line_number,character_number filename\nIf you omit the character_number, the cursor will be positioned on the first character.",
    "crumbs": [
      "Additional resources",
      "Text editors: nano"
    ]
  },
  {
    "objectID": "nano.html#search-and-replace",
    "href": "nano.html#search-and-replace",
    "title": "Text editors: nano",
    "section": "2 Search and replace",
    "text": "2 Search and replace\nTo search for a text, press Ctrl + w, type in the search term, and press Enter. The cursor will move to the first match. To move to the next match, press Alt+w.\nIf you want to search and replace, press Ctrl + \\. Enter the search term and the text to be replaced with. The editor will move to the first match and ask you whether to replace it. After hitting Y or N, it will move to the next match. Pressing A will replace all matches.",
    "crumbs": [
      "Additional resources",
      "Text editors: nano"
    ]
  },
  {
    "objectID": "nano.html#copy-cut-and-paste",
    "href": "nano.html#copy-cut-and-paste",
    "title": "Text editors: nano",
    "section": "3 Copy, cut, and paste",
    "text": "3 Copy, cut, and paste\nTo select text, move the cursor to the beginning of the text and press Alt + a. This will set a selection mark. Move the cursor to the end of the text you want to select using the arrow keys. The selected text will be highlighted. If you wish to cancel the selection, press Ctrl + 6.\nCopy the selected text to the clipboard using the Alt + 6 command. Ctrl + k will cut the selected text.\nIf you want to cut whole lines, move the cursor to the line and press Ctrl + k. You can cut multiple lines by hitting Ctrl + k several times.\nTo paste the text, move the cursor to where you want to put the text and press Ctrl + u.",
    "crumbs": [
      "Additional resources",
      "Text editors: nano"
    ]
  },
  {
    "objectID": "nano.html#save-and-exit",
    "href": "nano.html#save-and-exit",
    "title": "Text editors: nano",
    "section": "4 Save and exit",
    "text": "4 Save and exit\nTo save the changes you’ve made to the file, select Ctrl + o. If the file doesn’t exist, it will be created once you save it.\nTo exit nano, select Ctrl + x. If there are unsaved changes, you’ll be asked whether you want to save the changes.\nTo save the file, you must have write permissions to the file. If you are creating a new file, you need to have write permission to the directory where the file is created.",
    "crumbs": [
      "Additional resources",
      "Text editors: nano"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Global Disease Modelling 2025 Workshop",
    "section": "",
    "text": "This workshop is held 13-15 January and 22 January 2025 for the Global Disease Modelling team at The Kids Research Institute Australia, in collaboration with Pawsey Supercomputing Centre.\nParticipating in the workshop means you agree to abide by our Code of Conduct.\nYou can access the sessions’ Q&A at slido.com using the code # 3151 5665 or by clicking this link. You can also use the Teams meeting’s chat to post any questions or comments.\n\nOutline\n\n13/1 (Mon) at 13:00-16:00: the Unix shell.\n14/1 (Tue) at 13:00-16:00: version control with Git.\n15/1 (Wed) at 13:00-16:00: a high-level overview of high-performance computing (HPC) including logging in, modules and containers, Slurm, and job submissions.\n22/1 (Wed) at 13:00-16:30: a Hackathon session. We will attempt to move our individual projects to Pawsey.\n\n\n\nSession schedule\nThe first part of the workshop is held 13 to 15 January 2025 from 13:00 to 16:00, with the following schedule:\n\n13:00-13:50 Workshop\n13:50-14:00 Break\n14:00-14:50 Workshop\n14:50-15:15 Afternoon tea\n15:15-16:00 Workshop\n\nThe last day of the workshop is a Hackathon held on 22 January 2025 from 13:00 to 16:30, with the following schedule:\n\n13:00-14:45 Hackathon\n14:45-15:15 Afternoon tea\n15:15-16:30 Hackathon",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "acknowledgements.html",
    "href": "acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "Acknowledgement of country\nThe Kids Research Institute Australia acknowledges Aboriginal people as the Traditional Owners of the land and seas of Australia. We also acknowledge the Noongar Nation and especially the Whadjuk people as the custodians of the land on which the Institute is located.\nWe pay our respects to Elders past, present, and future and seek their wisdom in our work to improve the health of all children.\n\n\nWorkshop material\nThank you to Lara Frcej and Victor Olet for preparing the workshop materials for Session 1 on Unix. Thank you to Victor Olet and Aurélien Cavelan for preparing the workshop materials for Session 2 on version control with Git. Thank you to Sarah Beecroft for preparing the workshop materials for Session 3 on an introduction to high performance computing. Thank you to Fathima Hassan, Sarah Beecroft, Victor Olet, Lara Frce, and Christopher Harris for supporting the preparation of the workshop.\n\n\nLicenses\n\nThe Code of Conduct is derived from work that is copyright © rOpenSci (rOpenSci Code of Conduct) made available under the CC BY 4.0 license.\nThe instruction material “Setting up” is derived from work that is copyright © The Carpentries (https://carpentries.org/) made available under the CC BY 4.0 license.\nThe instruction material “Unix Shell” is derived from work that is copyright © The Carpentries (https://carpentries.org/) made available under the CC BY 4.0 license.\nThe instruction material “Remote logins and SSH” is derived from works that are copyright © The Carpentries (https://carpentries.org/) and copyright © Pawsey (https://pawsey.atlassian.net/wiki/spaces/US/overview) made available under the CC BY 4.0 license; and copyright © GitHub, Inc. (https://docs.github.com/en) made available under the CC0 1.0 Universal Deed.\nThe instruction material “Text editors: nano” is derived from work that is copyright © The Carpentries (https://carpentries.org/) made available under the CC BY 4.0 license.\nThe instruction material “Text editors: Vim” is derived from work that is copyright © The Carpentries (https://carpentries.org/) made available under the CC BY 4.0 license.",
    "crumbs": [
      "Acknowledgements"
    ]
  },
  {
    "objectID": "pawsey.html",
    "href": "pawsey.html",
    "title": "Pawsey",
    "section": "",
    "text": "Logging in\nSecurity (SSH)\nMoving data (SCP, SFTP, Rsync, and GUIs)\nFinding and using available software\nSingularity (containers)\nSubmitting and monitoring jobs"
  },
  {
    "objectID": "pawsey.html#logging-in-using-ssh",
    "href": "pawsey.html#logging-in-using-ssh",
    "title": "Pawsey",
    "section": "1 Logging in using ssh",
    "text": "1 Logging in using ssh\nTo make a remote login, we issue the command ssh &lt;username&gt;@&lt;computer&gt; which tries to make a connection to the SSH daemon running on the remote computer we have specified. For Chitra to access the Setonix computer on Pawsey, she logs in using ssh chitrams@setonix.pawsey.org.au.\n\n\n\n\n\n\nTest your understanding\n\n\n\n\nWhat happens if Chitra has already been allocated a node named nid09310 that she would like to directly log in to?\nWhat happens if Chitra wants to access the data mover nodes on Pawsey, which has the hostname data-mover.pawsey.org.au?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFor the first instance, Chitra would log in with the following command:\nssh chitrams@nid09310.pawsey.org.au\nFor the second, Chitra would log in with the following command:\nsftp chitrams@data-mover.pawseyl.org.au\nwhere sftp is another companion program for ssh, the Secure File Transfer Protocol. We talk about this in a subsequent section.\n\n\n\nAfter we log in, we can use the remote shell to use the remote computer’s files and directories.\nTyping exit terminates the remote shell (and the local client program on that remote shell) and returns us to our previous shell."
  },
  {
    "objectID": "session-ssh.html",
    "href": "session-ssh.html",
    "title": "SSH keys and logging in",
    "section": "",
    "text": "Objectives\n\n\n\n\nSet up SSH keys for Git and Pawsey\nUnderstand “where” you are\n\n\n\n\nCheck whether you already have SSH keys set up. How would you do this? You may find Section 3 in the Remote logins and SSH page useful.\nSet up your SSH key for Git. You may find Section 3.1 in the Remote logins and SSH page useful.\nSet up your SSH key for Pawsey. You may find Section 3.2 in the Remote logins and SSH page useful.\nLog on to Pawsey using SSH. How do you know “where” you are? Is your terminal running on your local PC, or on Pawsey?\n\n\n\n\n\n\n\nDiscussion\n\n\n\nWhy do you think we use the shell, or the command line, when interacting with Pawsey? Why not use a graphical user interface (GUI)?"
  },
  {
    "objectID": "session-ssh.html#logging-in-ssh",
    "href": "session-ssh.html#logging-in-ssh",
    "title": "SSH keys and logging in",
    "section": "",
    "text": "Objectives\n\n\n\n\nSet up SSH keys for Git and Pawsey\nUnderstand “where” you are\n\n\n\n\nCheck whether you already have SSH keys set up. How would you do this? You may find Section 3 in the Remote logins and SSH page useful.\nSet up your SSH key for Git. You may find Section 3.1 in the Remote logins and SSH page useful.\nSet up your SSH key for Pawsey. You may find Section 3.2 in the Remote logins and SSH page useful.\nLog on to Pawsey using SSH. How do you know “where” you are? Is your terminal running on your local PC, or on Pawsey?\n\n\n\n\n\n\n\nDiscussion\n\n\n\nWhy do you think we use the shell, or the command line, when interacting with Pawsey? Why not use a graphical user interface (GUI)?"
  },
  {
    "objectID": "session-ssh.html#looking-around",
    "href": "session-ssh.html#looking-around",
    "title": "SSH keys and logging in",
    "section": "2 Looking around",
    "text": "2 Looking around\n\n\n\n\n\n\nObjectives\n\n\n\n\nNavigate Pawsey using the command line\nUnderstand user permissions\nUnderstand the Pawsey filesystem\n\n\n\n\nNavigate to your own software directory using cd $MYSOFTWARE. Now, navigate to the GROUP directory (also located within pawsey1104).\nCopy a folder within the software directory to your scratch directory. How would you do this?\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nSimilar to $MYSOFTWARE, there is an alias $MYSCRATCH for your scratch directory.\n\n\n\n\nNavigate to the copied folder within your scratch directory."
  },
  {
    "objectID": "collaborative-git.html",
    "href": "collaborative-git.html",
    "title": "Collaborative Git",
    "section": "",
    "text": "You’ve already committed and pushed changes to GitHub, and you’re comfortable with creating branches. In this section we’ll level up your Git knowledge to fully utilise Git for collaboration.\n\n\nThese questions encapsulate the concepts we will address in this section.\n\nWhat does it mean to have staged and unstaged changes?\nWhat is a branch? Where does it live?\nHow do you add a second remote, and why would you want multiple remote repositories?\nHow do I incorporate someone else’s changes with the changes I’ve made, if we’ve both committed to the same branch at the same time?\nHow do you re-write history if you’re unhappy with the direction your project has taken?\nFollowing up on the previous question, can you choose to keep only some changes and not others?\n\n\n\n\n\nWe will discuss what happens when staging, committing, and pushing\nWe will discuss branches, remotes, and pull requests: what they are and how to use them\nWe will discuss what is considered best practice for commits, pushing, and branches on the command line\nWe will discuss what is considered best practice for team workflows, including how to use pull requests on GitHub\nWe will look at how to use revert, reset, merge, and cherry-pick, especially when collaborating with others"
  },
  {
    "objectID": "collaborative-git.html#introduction",
    "href": "collaborative-git.html#introduction",
    "title": "Collaborative Git",
    "section": "",
    "text": "You’ve already committed and pushed changes to GitHub, and you’re comfortable with creating branches. In this section we’ll level up your Git knowledge to fully utilise Git for collaboration.\n\n\nThese questions encapsulate the concepts we will address in this section.\n\nWhat does it mean to have staged and unstaged changes?\nWhat is a branch? Where does it live?\nHow do you add a second remote, and why would you want multiple remote repositories?\nHow do I incorporate someone else’s changes with the changes I’ve made, if we’ve both committed to the same branch at the same time?\nHow do you re-write history if you’re unhappy with the direction your project has taken?\nFollowing up on the previous question, can you choose to keep only some changes and not others?\n\n\n\n\n\nWe will discuss what happens when staging, committing, and pushing\nWe will discuss branches, remotes, and pull requests: what they are and how to use them\nWe will discuss what is considered best practice for commits, pushing, and branches on the command line\nWe will discuss what is considered best practice for team workflows, including how to use pull requests on GitHub\nWe will look at how to use revert, reset, merge, and cherry-pick, especially when collaborating with others"
  },
  {
    "objectID": "collaborative-git.html#background",
    "href": "collaborative-git.html#background",
    "title": "Collaborative Git",
    "section": "2 Background",
    "text": "2 Background\n\n\n\n\n\n\nOverview\n\n\n\n\nWhat is version control?\nWhy should I use it?\n\n\n\nWhy we like version control:\n\nNothing that is committed to version control is ever lost, unless you work really, really hard at losing it. Since all old versions of files are saved, it’s always possible to go back in time to see exactly who wrote what on a particular day, or what version of a program was used to generate a particular set of results.\nAs we have this record of who made what changes when, we know who to ask if we have questions later on, and, if needed, revert to a previous version, much like the “undo” feature in an editor.\nWhen several people collaborate in the same project, it’s possible to accidentally overlook or overwrite someone’s changes. The version control system automatically notifies users whenever there’s a conflict between one person’s work and another’s.\n\nTeams are not the only ones to benefit from version control: lone researchers can benefit immensely. Keeping a record of what was changed, when, and why is extremely useful for all researchers if they ever need to come back to the project later on (e.g., a year later, when memory has faded).\nVersion control is the lab notebook of the digital world: it’s what professionals use to keep track of what they’ve done and to collaborate with other people. Every large software development project relies on it, and most programmers use it for their small jobs as well. And it isn’t just for software: books, papers, small data sets, and anything that changes over time or needs to be shared can and should be stored in a version control system.\nWe’ll start by exploring how version control can be used to keep track of what one person did and when. Even if you aren’t collaborating with other people, automated version control is much better than this situation:\n\n\n\n\n\nWe’ve all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document. Some word processors let us deal with this a little better, such as Microsoft Word’s Track Changes, Google Docs’ version history, or LibreOffice’s Recording and Displaying Changes.\nVersion control systems start with a base version of the document and then record changes you make each step of the way. You can think of it as a recording of your progress: you can rewind to start at the base document and play back each change you made, eventually arriving at your more recent version.\nOnce you think of changes as separate from the document itself, you can then think about “playing back” different sets of changes on the base document, ultimately resulting in different versions of that document. For example, two users can make independent sets of changes on the same document.\nUnless multiple users make changes to the same section of the document-a conflict–you can incorporate two sets of changes into the same base document.\nA version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files. It allows us to decide which changes will be made to the next version (each record of these changes is called a commit), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a repository. Repositories can be kept in sync across different computers, facilitating collaboration among different people.\nAutomated version control systems are nothing new. Tools like RCS, CVS, or Subversion have been around since the early 1980s and are used by many large companies. However, many of these are now considered legacy systems (i.e., outdated) due to various limitations in their capabilities. More modern systems, such as Git and Mercurial, are distributed, meaning that they do not need a centralized server to host the repository. These modern systems also include powerful merging tools that make it possible for multiple authors to work on the same files concurrently.\n\n\n\n\n\n\nKey points\n\n\n\n\nVersion control is like an unlimited “undo”\nVersion control allows multiple people to work concurrently."
  },
  {
    "objectID": "vim.html",
    "href": "vim.html",
    "title": "Text editors: Vim",
    "section": "",
    "text": "Vim is a text editor. That is all it does. You cannot format a document, insert shapes, make a table with lines, use multiple fonts, highlight sentences, or print out with headings or margins. Vim, however, is very good at editing text. Once you’ve mastered Vim, it is very powerful. You can find and replace chunks of text using commands, copy and paste columns of data, and jump to a specified line number.\n\n\n\n\n\n\nWhat is a text editor?\n\n\n\nWe sometimes call programs like Microsoft Word or LibreOffice Writer “text editors”, but we need to be a bit more careful when it comes to programming.\nBy default, Microsoft Word uses .docx files to store not only text, but also formatting information about fonts, headings, and so on. This extra information isn’t stored as characters, and doesn’t mean anything to tools like head: they expect input files to contain nothing but the letters, digits and punctuation on a standard computer keyboard. When editing programs, therefore, you must either use a plain text editor, or be careful to save files as plain text.\n\n\nVim is also everywhere. If you are working on a computer with a shell (such as terminal or gitbash), then you have Vim; it’s already there. And you can open it directly from the shell. The problem is, however, that Vim is notoriously difficult to learn.\nLet’s create a new file with Vim. First, open your shell, then type:\nvim new-file.txt\nYay, a new file! Now, close that file. Type:\n:q\nTa-da! Congratulations, you’ve exited vim.",
    "crumbs": [
      "Additional resources",
      "Text editors: Vim"
    ]
  },
  {
    "objectID": "vim.html#starting-vim",
    "href": "vim.html#starting-vim",
    "title": "Text editors: Vim",
    "section": "",
    "text": "Vim is a text editor. That is all it does. You cannot format a document, insert shapes, make a table with lines, use multiple fonts, highlight sentences, or print out with headings or margins. Vim, however, is very good at editing text. Once you’ve mastered Vim, it is very powerful. You can find and replace chunks of text using commands, copy and paste columns of data, and jump to a specified line number.\n\n\n\n\n\n\nWhat is a text editor?\n\n\n\nWe sometimes call programs like Microsoft Word or LibreOffice Writer “text editors”, but we need to be a bit more careful when it comes to programming.\nBy default, Microsoft Word uses .docx files to store not only text, but also formatting information about fonts, headings, and so on. This extra information isn’t stored as characters, and doesn’t mean anything to tools like head: they expect input files to contain nothing but the letters, digits and punctuation on a standard computer keyboard. When editing programs, therefore, you must either use a plain text editor, or be careful to save files as plain text.\n\n\nVim is also everywhere. If you are working on a computer with a shell (such as terminal or gitbash), then you have Vim; it’s already there. And you can open it directly from the shell. The problem is, however, that Vim is notoriously difficult to learn.\nLet’s create a new file with Vim. First, open your shell, then type:\nvim new-file.txt\nYay, a new file! Now, close that file. Type:\n:q\nTa-da! Congratulations, you’ve exited vim.",
    "crumbs": [
      "Additional resources",
      "Text editors: Vim"
    ]
  },
  {
    "objectID": "vim.html#text-editing",
    "href": "vim.html#text-editing",
    "title": "Text editors: Vim",
    "section": "2 Text editing",
    "text": "2 Text editing\nSo, you’ve created and exited a file with Vim. Your next challenge is to put some text inside the file. Open your file again:\nvim new-file.txt\nNow, try and type some text. What’s happening? You are currently in Normal (or ‘control’) mode. To add text, you need to be in Insert or ‘edit’ mode.\nTo enter Insert mode, type i. You can now type! Add some text:\nYay I can now add words to my file! This wasn't difficult at all!\nHow do you save your work? Ctrl + s will not help you. First, you need to go back to Normal mode by pressing Esc, then type:\n:w\n(If you spend too much time working in Vim, your text documents start to accumulate random :w in them.) Now, you can safely quit vim again:\n:q\nPractice this. Re-open your vim document, enter insert mode, and add some more random text.\nThere is also a command for saving and exiting all in one instruction. Press Esc, then type:\n:x\nPhew! You had little control over where your new text went in the last exercise. How do you move around in vim? In Normal mode, you can move one character at a time using your arrow keys, or the keys K (up), L (right), H (left), and J (down).\nOnce you are in place, type i to enter Insert mode on the left-hand-side of the current character. You can also type a to enter Insert mode on the right-hand-side (think (a)fter the character). Try this out and add some more text.\n\n\n\n\n\n\nSummary of Vim modes\n\n\n\nVim has several modes. For our purposes, the Normal mode and Insert mode are the most important.\n\nNormal mode is the default mode for navigating and manipulating text.\n\nTo enter, press Esc from any other mode.\nUse this mode for moving around the file, deleting text, copying, pasting, and other commands.\n\nInsert mode is used for inserting and editing text.\n\nTo enter this mode, press i, I, a, A, o, or O from Normal mode.\nUse this mode to type text directly into the document.",
    "crumbs": [
      "Additional resources",
      "Text editors: Vim"
    ]
  },
  {
    "objectID": "vim.html#useful-shortcuts",
    "href": "vim.html#useful-shortcuts",
    "title": "Text editors: Vim",
    "section": "3 Useful shortcuts",
    "text": "3 Useful shortcuts\n\n/pattern searches forward from the current cursor position for the text matching pattern. Type /, type the search term (pattern), and press Enter.\n\nTo search for the word “example”: first, ensure you are in Normal mode by pressing Esc. Then type /example and press Enter.\nTo navigate search results, n moves to the next occurrence of the search pattern.\nN moves to the previous occurrence of the search pattern.\n\n?pattern searches backward from the current cursor position for the text matching pattern. Press ?, type the search term (pattern), and press Enter.\n\nTo search backward for the word “example”, you would type ?example in Normal mode and press Enter.",
    "crumbs": [
      "Additional resources",
      "Text editors: Vim"
    ]
  },
  {
    "objectID": "best-practice-programming.html#best-practice-git",
    "href": "best-practice-programming.html#best-practice-git",
    "title": "Best practices for programming",
    "section": "Best practice Git",
    "text": "Best practice Git\n\nCommit names\nBranch names"
  },
  {
    "objectID": "best-practice-programming.html#best-practice-pawsey",
    "href": "best-practice-programming.html#best-practice-pawsey",
    "title": "Best practices for programming",
    "section": "Best practice Pawsey",
    "text": "Best practice Pawsey"
  },
  {
    "objectID": "best-practice-programming.html#modularisation",
    "href": "best-practice-programming.html#modularisation",
    "title": "Best practices for programming",
    "section": "Modularisation",
    "text": "Modularisation"
  },
  {
    "objectID": "best-practice-programming.html#resources",
    "href": "best-practice-programming.html#resources",
    "title": "Best practices for programming",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "supercomputing.html",
    "href": "supercomputing.html",
    "title": "Supercomputing fundamentals",
    "section": "",
    "text": "Components of a supercomputer\nFilesystem of a supercomputer\nSupercomputer modules\nScheduler (Slurm)\nBatch scripting\nObject storage\n\n\n\n\nGeneral architecture of a supercomputer"
  },
  {
    "objectID": "session-3.html#slurm-job-arrays",
    "href": "session-3.html#slurm-job-arrays",
    "title": "Session 3",
    "section": "2 Slurm job arrays",
    "text": "2 Slurm job arrays"
  },
  {
    "objectID": "session-3.html#intro-to-nextflow",
    "href": "session-3.html#intro-to-nextflow",
    "title": "Session 3",
    "section": "3 Intro to Nextflow",
    "text": "3 Intro to Nextflow"
  },
  {
    "objectID": "session-3.html#moving-your-project-to-pawsey",
    "href": "session-3.html#moving-your-project-to-pawsey",
    "title": "Session 3",
    "section": "4 Moving your project to Pawsey",
    "text": "4 Moving your project to Pawsey"
  },
  {
    "objectID": "session-hackathon.html",
    "href": "session-hackathon.html",
    "title": "Hackathon session",
    "section": "",
    "text": "In this Hackathon-style session, we will start transitioning our projects onto Pawsey. Facilitators from Pawsey will be around to help us with this.\nYou can access the Q&A at slido.com using the code # 3151 5665 or by clicking this link. You can also use the Teams meeting’s chat to post any questions or comments.",
    "crumbs": [
      "Workshop material",
      "Hackathon"
    ]
  },
  {
    "objectID": "unix-shell.html",
    "href": "unix-shell.html",
    "title": "Unix shell",
    "section": "",
    "text": "The shell is a program that enables us to send commands to the computer and receive output. It is also referred to as the terminal or command line. Use of the shell is fundamental to a wide range of advanced computing tasks, including high-performance computing. This section will introduce you to this powerful tool.\nFirst, open a terminal. If you’re not sure how to open a terminal on your operating system (OS), see the instructions in the box “Shells for various OS” below.",
    "crumbs": [
      "Additional resources",
      "Unix shell"
    ]
  },
  {
    "objectID": "unix-shell.html#introducing-the-shell",
    "href": "unix-shell.html#introducing-the-shell",
    "title": "Unix shell",
    "section": "1 Introducing the Shell",
    "text": "1 Introducing the Shell\n\n\n\n\n\n\nOverview\n\n\n\n\nWhat is a command shell?\nWhy would I use one?\n\n\n\n\n1.1 Background\nHumans and computers commonly interact in many different ways, such as through a keyboard and mouse, touch screen interfaces, or using speech recognition systems. The most widely used way to interact with personal computers is called a graphical user interface (GUI). With a GUI, we give instructions by clicking a mouse and using menu-driven interactions.\nWhile the visual aid of a GUI makes it intuitive to learn, this way of delivering instructions to a computer scales very poorly. Imagine the following task: for a literature search, you have to copy the third line of one thousand text files in one thousand different directories and paste it into a single file. Using a GUI, you would not only be clicking at your desk for several hours, but you could potentially also commit an error in the process of completing this repetitive task. This is where we take advantage of the Unix shell. The Unix shell is both a command-line interface (CLI) and a scripting language, allowing such repetitive tasks to be done automatically and fast. With the proper commands, the shell can repeat tasks with or without some modification as many times as we want. Using the shell, the task in the literature example can be accomplished in seconds.\n\n\n1.2 The Shell\nThe shell is a program where users can type commands. With the shell, it’s possible to invoke complicated programs like malaria simulation software or simple commands that create an empty directory with only one line of code. The most popular Unix shell is Bash (the Bourne Again SHell — so-called because it’s derived from a shell written by Stephen Bourne). Bash is the default shell on most modern implementations of Unix and in most packages that provide Unix-like tools for Windows. Note that ‘Git Bash’ is a piece of software that enables Windows users to use a Bash like interface when interacting with Git.\nUsing the shell will take some effort and some time to learn. While a GUI presents you with choices to select, CLI choices are not automatically presented to you, so you must learn a few commands like new vocabulary in a language you’re studying. However, unlike a spoken language, a small number of “words” (i.e. commands) gets you a long way, and we’ll cover those essential few today.\nThe grammar of a shell allows you to combine existing tools into powerful pipelines and handle large volumes of data automatically. Sequences of commands can be written into a script, improving the reproducibility of workflows.\nIn addition, the command line is often the easiest way to interact with remote machines and supercomputers. Familiarity with the shell is near essential to run a variety of specialized tools and resources including high-performance computing systems. As clusters and cloud computing systems become more popular for scientific data crunching, being able to interact with the shell is becoming a necessary skill. We can build on the command-line skills covered here to tackle a wide range of scientific questions and computational challenges.",
    "crumbs": [
      "Additional resources",
      "Unix shell"
    ]
  },
  {
    "objectID": "unix-shell.html#useful-shortcuts",
    "href": "unix-shell.html#useful-shortcuts",
    "title": "Unix shell",
    "section": "2 Useful shortcuts",
    "text": "2 Useful shortcuts\n\nPress Tab to auto-complete names (such as files, folders, or programs) in your current directory.\nPressing Ctrl + c cancels what you’ve written or terminates a process that’s currently running\nChanging directories using cd:\n\nTyping cd ~ takes you to your home directory\nTyping cd - takes you to the last directory you were in, which is especially useful if you’re switching back and forth between two directories\n\nPressing the up arrow (↑) gives you the previous command you entered\nPressing Ctrl + r searches through your command line history",
    "crumbs": [
      "Additional resources",
      "Unix shell"
    ]
  },
  {
    "objectID": "unix-shell.html#files-and-directories",
    "href": "unix-shell.html#files-and-directories",
    "title": "Unix shell",
    "section": "3 Files and directories",
    "text": "3 Files and directories\n\n\n\n\n\n\nOverview\n\n\n\n\nHow can I move around on my computer?\nHow can I see what files and directories I have?\nHow can I specify the location of a file or directory on my computer?\n\n\n\n\n3.1 Useful commands\n\ncd &lt;path&gt; changes the current working directory.\nls &lt;path&gt; prints a listing of a specific file or directory; ls on its own lists the current working directory.\npwd prints the user’s current working directory.\ncp &lt;old-path&gt; &lt;new-path&gt; copies a file.\nmkdir &lt;path&gt; creates a new directory.\nmv &lt;old&gt; &lt;new&gt; moves (renames) a file or directory.\nrm &lt;path&gt; removes (deletes) a file.\n\n\n\n3.2 Understanding files and directories\nTo navigate files and directories:\n\nThe file system is responsible for managing information on the disk.\nInformation is stored in files, which are stored in directories (folders).\nDirectories can also store other directories, which forms a directory tree.\nA relative path specifies a location starting from the current location.\nAn absolute path specifies a location from the root of the file system.\nDirectory names in a path are separated with / on Unix, but \\ on Windows.\n/ on its own is the root directory of the whole file system.\n.. means ‘the directory above the current one’; . on its own means ‘the current directory’.\n\nWorking with files and directories:\n\nThe shell does not have a trash bin: once something is deleted, it’s really gone.\nMost files’ names are something.extension. The extension isn’t required, and doesn’t guarantee anything, but is normally used to indicate the type of data in the file.",
    "crumbs": [
      "Additional resources",
      "Unix shell"
    ]
  },
  {
    "objectID": "unix-shell.html#scripts",
    "href": "unix-shell.html#scripts",
    "title": "Unix shell",
    "section": "4 Scripts",
    "text": "4 Scripts\n\n\n\n\n\n\nOverview\n\n\n\n\nHow can I save and reuse commands using bash?\n\n\n\nTo use Pawsey supercomputers, you will need to create batch job scripts (also called job scripts or batch scripts) to run your code. For historical reasons, a bunch of commands saved in a file is usually called ascript, but make no mistake: these are actually small programs. Not only will writing scripts make your work faster, but you also won’t have to retype the same commands over and over again. It will also make it more accurate (fewer chances for typos) and more reproducible. If you come back to your work later (or if someone else finds your work and wants to build on it), you will be able to reproduce the same results simply by running your script, rather than having to remember or retype a long list of commands.\n\n4.1 Useful commands\n\nbash &lt;filename&gt; runs the commands saved in a file.\n$@ refers to all of a shell script’s command-line arguments.\n$1, $2, etc., refer to the first command-line argument, the second command-line argument, etc.",
    "crumbs": [
      "Additional resources",
      "Unix shell"
    ]
  },
  {
    "objectID": "unix-shell.html#finding-things",
    "href": "unix-shell.html#finding-things",
    "title": "Unix shell",
    "section": "5 Finding things",
    "text": "5 Finding things\n\n\n\n\n\n\nOverview\n\n\n\n\nHow can I find files?\nHow can I find things in files?\n\n\n\n\nfind finds files with specific properties that match patterns.\ngrep selects lines in files that match patterns.\n--help is an option supported by many bash commands, and programs that can be run from within Bash, to display more information on how to use these commands or programs.\nman &lt;command&gt; displays the manual page for a given command.\n$(&lt;command&gt;) inserts a command’s output in place.\n\nHere is an example of how you would combine the above commands.\n$ grep \"searching\" $(find . -name \"*.txt\")\nThe first (grep) finds files that match a pattern; the second (find) looks for lines inside those files that match another pattern. Here, for example, we can find txt files that contain the word “searching” by looking for the string ‘searching’ in all the .txt files in the current directory.\nHere is what the output would look like:\n./writing/LittleWomen.txt:sitting on the top step, affected to be searching for her book, but was\n./writing/haiku.txt:With searching comes loss",
    "crumbs": [
      "Additional resources",
      "Unix shell"
    ]
  },
  {
    "objectID": "unix-shell.html#permissions-chmod",
    "href": "unix-shell.html#permissions-chmod",
    "title": "Unix shell",
    "section": "6 Permissions (chmod)",
    "text": "6 Permissions (chmod)\n\n\n\n\n\n\nOverview\n\n\n\n\nWhat are file or directory permissions?\nHow do I view permissions?\nHow do I change permissions?\n\n\n\nUnix controls who can read, modify, and run files using permissions. Let’s start with the user. I, Chitra, have a unique user name chitrams and user ID 26156. Users can belong to any number of groups, each of which has a unique group name and numeric group ID. Our group name is pawsey1104 with group ID 35725.\n\n\n\n\n\n\nTip\n\n\n\nRun id on the terminal to see your user details. You can also run this on the Pawsey terminal to see the group details.\n\n\n\n\n\n\n\n\nWhy use integers for IDs?\n\n\n\n\n\nThe answer goes back to the early 1970s. Character strings like alan.turing are of varying length, and comparing one to another takes many instructions. Integers, on the other hand, use a fairly small amount of storage (typically four characters), and can be compared with a single instruction. To make operations fast and simple, programmers often keep track of things internally using integers, then use a lookup table of some kind to translate those integers into user-friendly text for presentation.\nOf course, programmers being programmers, they will often skip the user-friendly string part and just use the integers, in the same way that someone working in a lab might talk about Experiment 28 instead of “the chronotypical alpha-response trials on anacondas”.\n\n\n\nNow let’s look at files and directories. Every file and directory on a Unix computer belongs to one owner and one group. Along with each file’s content, the operating system stores the numeric IDs of the user and group that own it.\nThe user-and-group model means that for each file every user on the system falls into one of three categories: the owner of the file, someone in the file’s group, and everyone else. For each of these three categories, the computer keeps track of whether people in that category can read the file, write to the file, or execute the file (i.e., run it if it is a program). For example, if a file had the following set of permissions:\n\n\n\n\nuser\ngroup\nall\n\n\n\n\nread\nyes\nyes\nno\n\n\nwrite\nyes\nno\nno\n\n\nexecute\nno\nno\nno\n\n\n\nit would mean that:\n\nthe file’s owner can read and write it, but not run it;\nother people in the file’s group can read it, but not modify it or run it; and\neverybody else can do nothing with it at all.\n\nLet’s look at this in action. If we cd into the GROUP directory on Pawsey (/software/projects/pawsey1104/GROUP) and run the command ls -l:\n$ ls -l\ntotal 20\ndrwxrws---  7 chitrams pawsey1104 4096 Oct  5 08:05 MAP_data\ndrwxrwx---  2 chitrams chitrams   4096 Dec  2 16:22 chatbox-om\ndrwxrwsr-x  3 acavelan pawsey1104 4096 Sep 25 16:11 OpenMalaria\ndrwxrwxr-x  6 acavelan pawsey1104 4096 Jul 13  2021 RASTERS\ndrwxrwxr-x 10 acavelan pawsey1104 4096 Aug 18  2023 SHAPEFILES\nThe -l flag tells ls to give us a long-form listing. It’s a lot of information, so let’s go through the columns in turn.\nOn the right side, we have the files’ names. Next to them, moving left, are the times and dates they were last modified. Backup systems and other tools use this information in a variety of ways, but you can use it to tell when you (or anyone else with permission) last changed a file.\nNext to the modification time is the file’s size in bytes and the names of the user and group that owns it (in this case, chitrams and pawsey1104 respectively). We’ll skip over the second column for now (the one showing 7 in the first line) because it’s the first column that we care about most. This shows the file’s permissions, i.e., who can read, write, or execute it.\nLet’s have a closer look at one of those permission strings: drwxrwx---. The first character tells us what type of thing this is: d means it’s a directory, while - means it’s a regular file.\nThe next three characters tell us what permissions the file’s owner has. Here, the owner can read, write, and execute the file: rwx. The middle triplet shows us the group’s permissions. If the permission is turned off, we see a dash, so r-x means “read and execute, but not write”. When we see rws it means that new files and subdirectories created within that directory will inherit the group of the directory. The final triplet shows us what everyone who isn’t the file’s owner, or in the file’s group, can do. In this case, it’s ---, so no one outside of the group can look at the file’s contents and run it.\nTo change permissions, we use the chmod command (whose name stands for “change mode”). Here’s a long-form listing showing the permissions on an R script Chitra is using:\n$ ls -l launch.R\n-rw-r--r-- 1 chitrams pawsey1104 15784 Nov 15 13:45 launch.R\nWhoops, Chitra can’t execute the R script on Pawsey! The command to change the owner’s permission to rwx is:\n$ chmod u=rwx launch.R\nLet’s run chmod again to give the group write permission but not execution; and everyone else no permission to read, write, or execute:\n$ chmod g=rw launch.R\n$ chmod o=--- launch.R\n-rwxrw---- 1 chitrams pawsey1104 15784 Nov 15 13:45 launch.R",
    "crumbs": [
      "Additional resources",
      "Unix shell"
    ]
  }
]